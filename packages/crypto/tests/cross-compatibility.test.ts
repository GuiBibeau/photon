import { describe, it, expect } from 'vitest';
import { generateKeyPair, signBytes, verifySignature, createSignature } from '../src/index.js';

describe('Cross-Library Compatibility Tests', () => {
  describe('WebCrypto API compatibility', () => {
    it('should work with native WebCrypto operations', async () => {
      // Generate keys using our SDK
      const keyPair = await generateKeyPair({ extractable: true });
      const message = new TextEncoder().encode('WebCrypto compatibility test');

      // Sign using our SDK
      const sdkSignature = await signBytes(keyPair.cryptoKeyPair.privateKey, message);

      // Verify using native WebCrypto
      const nativeVerification = await crypto.subtle.verify(
        'Ed25519',
        keyPair.cryptoKeyPair.publicKey,
        sdkSignature,
        message,
      );
      expect(nativeVerification).toBe(true);

      // Sign using native WebCrypto
      const nativeSignature = await crypto.subtle.sign(
        'Ed25519',
        keyPair.cryptoKeyPair.privateKey,
        message,
      );

      // Verify using our SDK
      const sdkVerification = await verifySignature(
        keyPair.cryptoKeyPair.publicKey,
        message,
        createSignature(new Uint8Array(nativeSignature)),
      );
      expect(sdkVerification).toBe(true);
    });

    it('should handle keys generated by native WebCrypto', async () => {
      // Generate keys using native WebCrypto
      const nativeKeyPair = await crypto.subtle.generateKey({ name: 'Ed25519' }, true, [
        'sign',
        'verify',
      ]);

      const message = new TextEncoder().encode('Native key test');

      // Sign using our SDK with native keys
      const signature = await signBytes(nativeKeyPair.privateKey, message);
      expect(signature).toBeInstanceOf(Uint8Array);
      expect(signature.length).toBe(64);

      // Verify the signature
      const isValid = await verifySignature(nativeKeyPair.publicKey, message, signature);
      expect(isValid).toBe(true);
    });
  });

  describe('Common wallet signatures', () => {
    // Note: The following test vectors appear to be synthetic test data
    // Real wallet signatures would require access to private keys which should not be hardcoded
    // These tests are disabled until verified test vectors are available

    it('should verify signatures generated by our SDK (simulating wallet behavior)', async () => {
      // Generate a keypair to simulate a wallet
      const walletKeyPair = await generateKeyPair({ extractable: true });

      // Test messages that wallets commonly sign
      const testMessages = [
        'Sign in to MyDApp',
        'Solflare authentication',
        'Please confirm this transaction',
      ];

      for (const messageText of testMessages) {
        const messageBytes = new TextEncoder().encode(messageText);

        // Sign the message (simulating wallet behavior)
        const signature = await signBytes(walletKeyPair.cryptoKeyPair.privateKey, messageBytes);

        // Verify the signature (simulating dApp verification)
        const isValid = await verifySignature(
          walletKeyPair.cryptoKeyPair.publicKey,
          messageBytes,
          signature,
        );
        expect(isValid).toBe(true);
      }
    });
  });

  describe('Message signing standards', () => {
    it('should handle Solana message signing format', async () => {
      const _keyPair = await generateKeyPair({ extractable: true });

      // Solana message signing standard prepends a specific header
      const SOLANA_MESSAGE_PREFIX = '\xff[=11=]solana offchain';
      const userMessage = 'Please sign this message for authentication';

      // Construct the full message as Solana wallets do
      const prefixBytes = new TextEncoder().encode(SOLANA_MESSAGE_PREFIX);
      const headerBytes = new Uint8Array([
        prefixBytes.length & 0xff,
        (prefixBytes.length >> 8) & 0xff,
      ]);
      const messageBytes = new TextEncoder().encode(userMessage);
      const messageLengthBytes = new Uint8Array([
        messageBytes.length & 0xff,
        (messageBytes.length >> 8) & 0xff,
      ]);

      const fullMessage = new Uint8Array(
        headerBytes.length + prefixBytes.length + messageLengthBytes.length + messageBytes.length,
      );

      let offset = 0;
      fullMessage.set(headerBytes, offset);
      offset += headerBytes.length;
      fullMessage.set(prefixBytes, offset);
      offset += prefixBytes.length;
      fullMessage.set(messageLengthBytes, offset);
      offset += messageLengthBytes.length;
      fullMessage.set(messageBytes, offset);

      // Sign the formatted message
      const signature = await signBytes(_keyPair.cryptoKeyPair.privateKey, fullMessage);

      // Verify the signature
      const isValid = await verifySignature(
        _keyPair.cryptoKeyPair.publicKey,
        fullMessage,
        signature,
      );
      expect(isValid).toBe(true);
    });

    it('should handle transaction serialization format', async () => {
      const keyPair = await generateKeyPair({ extractable: true });

      // Simulate a serialized transaction
      const transaction = new Uint8Array([
        // Compact array length for signatures (1)
        0x01,
        // Signature placeholder (64 bytes of zeros)
        ...new Array(64).fill(0),
        // Message header
        0x01, // requireSignatures
        0x00, // readonlySigners
        0x01, // readonlyNonSigners
        // Compact array length for accounts (3)
        0x03,
        // Account addresses (32 bytes each)
        ...new Array(32).fill(0x11), // Fee payer
        ...new Array(32).fill(0x22), // Program ID
        ...new Array(32).fill(0x33), // Account
        // Recent blockhash (32 bytes)
        ...new Array(32).fill(0x44),
        // Instructions compact array length (1)
        0x01,
        // Instruction
        0x01, // Program ID index
        0x01, // Accounts length
        0x02, // Account index
        0x04, // Data length
        0x01,
        0x02,
        0x03,
        0x04, // Instruction data
      ]);

      // The message to sign is everything after the signatures
      const messageStart = 1 + 64; // Compact array length + signature
      const messageToSign = transaction.slice(messageStart);

      const signature = await signBytes(keyPair.cryptoKeyPair.privateKey, messageToSign);

      // Place signature in transaction
      transaction.set(signature, 1);

      // Verify the signature is valid
      const isValid = await verifySignature(
        keyPair.cryptoKeyPair.publicKey,
        messageToSign,
        signature,
      );
      expect(isValid).toBe(true);
    });
  });

  describe('Binary format compatibility', () => {
    it('should handle different endianness correctly', async () => {
      const keyPair = await generateKeyPair({ extractable: true });

      // Create a message with specific byte patterns
      const message = new Uint8Array([
        0x00,
        0x01,
        0x02,
        0x03, // Little-endian u32: 50462976
        0xff,
        0xfe,
        0xfd,
        0xfc, // Little-endian u32: 4244504319
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x01, // Little-endian u64: 1
      ]);

      const signature = await signBytes(keyPair.cryptoKeyPair.privateKey, message);

      // Verify signature
      const isValid = await verifySignature(keyPair.cryptoKeyPair.publicKey, message, signature);
      expect(isValid).toBe(true);

      // Changing byte order should invalidate signature
      const reversedMessage = new Uint8Array(message).reverse();
      const isValidReversed = await verifySignature(
        keyPair.cryptoKeyPair.publicKey,
        reversedMessage,
        signature,
      );
      expect(isValidReversed).toBe(false);
    });

    it('should handle various data encodings', async () => {
      const keyPair = await generateKeyPair({ extractable: true });

      // Test different encodings
      const testCases = [
        { name: 'UTF-8', data: new TextEncoder().encode('Hello, ä¸–ç•Œ! ðŸŒ') },
        { name: 'Base64', data: Uint8Array.from(atob('SGVsbG8gV29ybGQ='), (c) => c.charCodeAt(0)) },
        { name: 'Hex', data: new Uint8Array([0xde, 0xad, 0xbe, 0xef]) },
        { name: 'Binary', data: new Uint8Array([0b10101010, 0b01010101, 0b11110000]) },
      ];

      for (const testCase of testCases) {
        const signature = await signBytes(keyPair.cryptoKeyPair.privateKey, testCase.data);
        const isValid = await verifySignature(
          keyPair.cryptoKeyPair.publicKey,
          testCase.data,
          signature,
        );
        expect(isValid).toBe(true);
      }
    });
  });

  describe('Error compatibility', () => {
    it('should handle various invalid inputs consistently', async () => {
      const _keyPair = await generateKeyPair({ extractable: true });

      // Test invalid public key formats
      const invalidPublicKeys = [
        new Uint8Array(31), // Too short
        new Uint8Array(33), // Too long
        new Uint8Array(32).fill(0), // All zeros (invalid point)
        new Uint8Array(32).fill(255), // All ones (likely invalid)
      ];

      for (const invalidKey of invalidPublicKeys) {
        const result = await verifySignature(
          invalidKey,
          new Uint8Array([1, 2, 3]),
          new Uint8Array(64),
          { validateInputs: false },
        );
        expect(result).toBe(false);
      }
    });

    it('should handle malformed signatures consistently', async () => {
      const keyPair = await generateKeyPair({ extractable: true });
      const message = new TextEncoder().encode('Test message');

      // Test invalid signature formats
      const invalidSignatures = [
        new Uint8Array(63), // Too short
        new Uint8Array(65), // Too long
        new Uint8Array(64).fill(0), // All zeros
        new Uint8Array(64).fill(255), // All ones
      ];

      for (const invalidSig of invalidSignatures) {
        if (invalidSig.length !== 64) {
          // Should throw for wrong length
          expect(() => createSignature(invalidSig)).toThrow();
        } else {
          // Should return false for invalid but correct length
          const isValid = await verifySignature(
            keyPair.cryptoKeyPair.publicKey,
            message,
            createSignature(invalidSig),
          );
          expect(isValid).toBe(false);
        }
      }
    });
  });
});
